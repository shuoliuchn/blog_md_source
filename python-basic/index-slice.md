## 索引和切片

[TOC]

### 索引（下标）

索引又称下标，用来表示可迭代对象中的某个元素的位置。

- 用正整数表示的索引值，从左向右定位，从 0 开始计数，如 0，1，2
- 用负整数表示的索引值，从右向左定位，从 -1 开始计数，如 -1，-2，-3

例如：

```python
name = "meet" # 计算机从0开始数
		#0123 (索引值|下标值) 从左向右
		#-4-3-2-1           从右向左

print(name[2])   # 通过索引准确定位内容
print(name[-4])  # 通过索引准确定位内容
```

输出的结果为：

```python
e
m
```

### 切片

有这样一个字符串：`meet_alex_wusir`，我们想要把其中的 `alex` 取出来，该怎么做呢？一个可行的方法是，分别用 `a`、`l`、`e` 和 `x` 的索引值，把它们分别取出来，再利用字符串的 `加和` 操作把它们拼接起来，就像这样：

```python
name = "meet_alex_wusir"
a = name[5] # 取出a
b = name[6] # 取出l
c = name[7] # 取出e
d = name[8] # 取出x
print(a + b + c + d) # 拼接并打印字符串
```

当然也可以通过循环的方法来取出相应的字符，然后拼接成新的字符串：

```python
name = "meet_alex_wusir"
i = 5
s = ''
while i <= 8:
    s += name[i]
    i += 1
print(s)
```

因为这样的循环在 Python 中非常常用，所以被封装成为了一种简便的方法，就是字符串的 `切片`。切片的基本格式和使用方法如下：

```python
name = "meet_alex_wusir"
      # 0123456789
print(name[5:9])  # [起始位置:终止位置]  顾头不顾腚（起始位置保留，终止位置不保留）
print(name[-5:])  # [起始位置:终止位置(默认到结尾)]  顾头不顾腚
print(name[:])  # [起始位置(默认从开头):终止位置(默认到结尾)]  顾头不顾腚


```

输出的结果为：

```python
alex
wusir
meet_alex_wusir
```

关于切片的终止位置的选择，还有一个技巧是：`终止位置 = 起始位置 + 切片长度`。例如上面的例子中，起始位置为 `5`，切片长度为 `4`，终止位置为 `5 + 4 = 9`。

有的时候我们并不想要一个一个取字符，而是要隔一个字符取一个。比如对于上面 `"meet_alex_wusir"` 的例子，我们想要取第 `3`、`5`、`7` 位的 `e`、`_`、`l`，该如何操作呢？

我们依旧可以使用最原始的，分别取值，然后拼接字符串的方法：

```python
name = "meet_alex_wusir"
a = name[2]
b = name[4]
c = name[6]
print(a + b + c)
```

这种方法确实能得到我们想要的结果，但是太过繁琐。如果我们想要处理很长的字符串，就会非常麻烦了。这就需要我们在切片时引入 `步长` 变量。`步长` 是使用切片方法的第三个参数，默认值为 `1`。对于上面的例子，我们可以设置 `步长` 为 `2`：

```python
name = "meet_alex_wusir"
       #0123456789
       #-6-5-4-3-2-1
print(name[2:7:2])  #[起始位置:终止位置:步长(默认为1)]
```

如果我们把步长设置成 -1，可以实现从右向左查找：

```python
name = "meet_alex_wusir"
print(name[-1:3:-1])  # 步长可以控制查找方向
```

输出的结果为：

```python
risuw_xela_
```

在进行索引操作时，如果输入的参数超过最大索引值时，程序会报错。而在进行切片操作时，如果终止位置超出最大索引值时，程序不会报错，而是会走到字符串的结尾：

```python
name = "meet_alex_wusir"
print(name[2:20:2])
```

输出的结果为：

```python
e_lxwsr
```

需要注意的是，索引和切片只能给有序数据（字符串、列表、元组）使用。整型和布尔值等均不可以用来进行索引和切片操作。

同整型一样，字符串也是一个**不可变**的数据类型：

```python
name = "meet"
print(id(name)) # 2388909933712
name = name + "最帅了"
print(id(name)) # 2388910157296
```

在 Python 中，对于字符串的赋值，还会有这样一个有趣的情况：

```python
name = "meet"
name1 = "meet"
print(id(name)) # 2313349022864
print(id(name1)) # 2313349022864
```

明明是两次赋值，两个字符串的内存地址居然是相同的。这是因为 Python 中有一个小数据池，小数据会驻留。在小数据驻留期间对相同的数据有新的赋值操作，不会新开辟一个内存空间，而是将变量指向已有数据的内存地址。小数据池机制是为了节省内存空间。